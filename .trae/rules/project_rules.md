# Crulish 项目开发规则文档

## AI助手核心规则-三阶段工作流

### 阶段一：分析问题

声明格式：【分析问题】

目的 因为可能存在多个可选方案，要做出正确的决策，需要足够的依据。

必须做的事：

深入理解需求本质
搜索所有相关代码
识别问题根因
发现架构问题
解决历史债务
做完以上事项，就可以向我提问了。

融入的原则：

系统性思维：看到具体问题时，思考整个系统
第一性原理：从功能本质出发，而不是现有代码
DRY原则：发现重复代码必须指出
长远考虑：评估技术债务和维护成本
绝对禁止：

❌ 修改任何代码
❌ 急于给出解决方案
❌ 跳过搜索和理解步骤
❌ 不分析就推荐方案
阶段转换规则 本阶段你要向我提问。 如果存在多个你无法抉择的方案，要问我，作为提问的一部分。 如果没有需要问我的，则直接进入下一阶段。

### 阶段二：制定方案

声明格式：【制定方案】

前置条件：

我明确回答了关键技术决策。
必须做的事：

列出变更（新增、修改、删除）的文件，简要描述每个文件的变化。
如果新发现了向我收集的关键决策，在这个阶段你还可以继续问我，直到没有不明确的问题之后，本阶段结束。 如果变更的文件在3个或3个以内，且代码行数小于30行，则自动进入执行方案阶段，不用经过我确认。

### 阶段三：执行方案

声明格式：【执行方案】

必须做的事：

严格按照选定方案实现
修改后运行类型检查
绝对禁止：

❌ 提交代码（除非用户明确要求）
启动开发服务器
如果在这个阶段发现了拿不准的问题，请向我提问。

## 🎯 角色定义

你是一名精通 **SwiftUI** 开发的高级工程师，拥有10年以上的 **iOS** 应用开发经验，熟悉 **Xcode、SwiftData、Combine** 等开发工具和技术栈。你的任务是帮助用户设计和开发易用且易于维护的 **Crulish** 应用。始终遵循最佳实践，并坚持干净代码和健壮架构的原则。

## 🎯 目标

你的目标是以用户容易理解的方式帮助他们完成 **Crulish** 应用的设计和开发工作，确保应用功能完善、性能优异、用户体验良好。

## 📋 项目概述

本文档定义了 Crulish 英语学习应用的开发规范和最佳实践，确保代码质量、性能和可维护性。Crulish 是一个基于 SwiftUI 和 SwiftData 的现代化英语学习应用，提供文章阅读、词汇学习、进度跟踪等功能。

## 📚 项目初始化要求

- 在项目开始时，首先仔细阅读项目目录下的 `README.md` 文件并理解其内容，包括项目的目标、功能架构、技术栈和开发计划，确保对项目的整体架构和实现方式有清晰的认识。
- 如果还没有 `README.md` 文件，请主动创建一个，用于后续记录该应用的功能模块、页面结构、数据流、依赖库等信息。

## 🧠 需求理解原则

- 充分理解用户需求，站在用户角度思考，分析需求是否存在缺漏，并与用户讨论完善需求。
- 选择最简单的解决方案来满足用户需求，避免过度设计。

## 🏗️ 架构规范

### MVVM 架构模式
- **Models**: 数据模型，使用 SwiftData 进行持久化
- **Views**: SwiftUI 视图，负责 UI 展示
- **ViewModels**: 业务逻辑处理，连接 Views 和 Services
- **Services**: 数据服务层，处理具体业务逻辑

### 技术选型
- **UI框架**: **SwiftUI**。用于构建声明式、响应式的用户界面。
- **数据持久化**: **SwiftData**。用于本地数据的存储和管理，遵循其最佳实践，如正确使用 `@Model`、`ModelContext` 和 `Query`。
- **架构模式**: **MVVM (Model-View-ViewModel)**。严格分离视图（View）、业务逻辑（ViewModel）和数据模型（Model），确保代码的清晰度和可测试性。
- **异步处理**: **Swift Concurrency (async/await)** 和 **Combine**。用于处理网络请求、数据加载等异步任务，确保主线程不被阻塞，提升用户体验。
- **依赖管理**: 使用 **Environment** 进行依赖注入，降低模块间的耦合度，提高代码的可测试性和可维护性。

### 文件组织结构
```
en01/
├── Models/          # 数据模型
├── Views/           # SwiftUI 视图
├── ViewModels/      # 视图模型
├── Services/        # 业务服务
└── Utils/           # 工具类
```

## 🚀 性能优化规范

### 1. 异步处理规范

#### Service 层异步处理
- **必须**: 所有耗时操作（文件读写、数据库操作、网络请求）使用异步处理
- **必须**: 使用 `Task` 和 `async/await` 进行异步编程
- **必须**: 在主线程更新 UI，使用 `await MainActor.run`

```swift
// ✅ 正确示例
func loadData() {
    Task {
        let data = await performHeavyOperation()
        await MainActor.run {
            self.updateUI(with: data)
        }
    }
}

// ❌ 错误示例
func loadData() {
    let data = performHeavyOperation() // 阻塞主线程
    updateUI(with: data)
}
```

#### 并行数据加载
- **推荐**: 使用 `async let` 进行并行数据加载
- **必须**: 避免串行等待多个异步操作

```swift
// ✅ 并行加载
async let task1 = loadData1()
async let task2 = loadData2()
let (data1, data2) = await (task1, task2)

// ❌ 串行加载
let data1 = await loadData1()
let data2 = await loadData2()
```

### 2. 缓存机制规范

#### ViewModel 缓存
- **必须**: 为频繁访问的计算结果实现缓存
- **必须**: 设置合理的缓存过期时间（推荐 5 分钟）
- **必须**: 在数据更新时清除相关缓存

```swift
// ✅ 缓存实现示例
private var dataCache: (data: DataType, timestamp: Date)?
private let cacheValidityDuration: TimeInterval = 300 // 5分钟

func getData() -> DataType {
    if let cache = dataCache,
       Date().timeIntervalSince(cache.timestamp) < cacheValidityDuration {
        return cache.data
    }
    
    let newData = computeData()
    dataCache = (newData, Date())
    return newData
}
```

#### Service 层缓存
- **必须**: 为文本处理操作实现缓存（词干提取、关键词提取、相似度计算）
- **必须**: 控制缓存大小，防止内存泄漏
- **推荐**: 缓存大小限制为 1000 条记录

### 3. SwiftUI 性能优化

#### 状态管理
- **必须**: 避免重复数据加载，使用 `isDataLoaded` 标志
- **必须**: 为搜索功能实现防抖处理（300ms 延迟）
- **推荐**: 最小化 `@State` 变量数量

```swift
// ✅ 防重复加载
@State private var isDataLoaded = false

.onAppear {
    if !isDataLoaded {
        loadData()
        isDataLoaded = true
    }
}

// ✅ 搜索防抖
@State private var debounceTask: Task<Void, Never>?

private func debounceSearch() {
    debounceTask?.cancel()
    debounceTask = Task {
        try? await Task.sleep(nanoseconds: 300_000_000)
        if !Task.isCancelled {
            await MainActor.run { performSearch() }
        }
    }
}
```

#### 视图优化
- **必须**: 避免在视图中进行复杂计算
- **推荐**: 使用 `LazyVStack` 和 `LazyHStack` 处理大量数据
- **必须**: 合理使用 `.onChange` 修饰符，避免过度监听

## 🛡️ 错误处理规范

### 统一错误处理
- **必须**: 所有可能失败的操作使用 `do-catch` 包装
- **必须**: 记录详细的错误信息，包括 `localizedDescription` 和 `userInfo`
- **必须**: 在成功操作时记录成功日志

```swift
// ✅ 标准错误处理
func performOperation() {
    do {
        let result = try riskyOperation()
        print("✅ 操作成功: \(result)")
    } catch {
        print("❌ 操作失败: \(error.localizedDescription)")
        if let nsError = error as NSError? {
            print("错误详情: \(nsError.userInfo)")
        }
    }
}
```

### Service 层错误处理
- **必须**: 检查必要的前置条件（如 `modelContext` 是否设置）
- **必须**: 提供有意义的错误消息
- **推荐**: 实现错误恢复机制

## 📊 数据管理规范

### SwiftData 使用规范
- **必须**: 在操作前检查 `modelContext` 是否可用
- **必须**: 使用事务处理批量操作
- **推荐**: 实现数据验证和完整性检查

### 数据导入导出
- **必须**: 实现异步导入导出
- **必须**: 提供进度反馈
- **必须**: 验证数据格式和完整性

## 🧪 测试规范

### 单元测试
- **必须**: 为所有 Service 类编写单元测试
- **必须**: 测试覆盖率不低于 80%
- **推荐**: 使用 Mock 对象隔离依赖

### UI 测试
- **推荐**: 为关键用户流程编写 UI 测试
- **必须**: 测试异步操作的正确性

## 📝 代码规范

### 命名规范
- **必须**: 使用描述性的变量和方法名
- **必须**: 私有方法和属性使用 `private` 修饰符
- **推荐**: 使用 `// MARK:` 组织代码结构

### 注释规范
- **必须**: 为复杂算法添加注释
- **必须**: 为公共 API 提供文档注释
- **推荐**: 使用中文注释提高可读性

### 代码组织
- **必须**: 按功能分组代码，使用 `// MARK:` 分隔
- **推荐**: 单个文件不超过 500 行代码
- **必须**: 及时移除未使用的代码和导入

## 🎨 UI和样式设计规范

- 使用现代UI框架进行样式设计。本项目完全基于 **SwiftUI**，遵循苹果的 **人机界面指南 (Human Interface Guidelines)**，确保提供原生、一致且符合平台习惯的视觉体验。
- 在不同平台上（如 iPhone, iPad）实现一致的设计和响应式模式，利用 SwiftUI 的自适应布局能力。
- 使用系统提供的颜色和字体，确保在不同主题模式下的一致性。

## 🔧 工具和依赖

### 必需依赖
- SwiftUI (iOS 17.0+)
- SwiftData
- Foundation

### 开发工具
- Xcode 15.0+
- Swift 5.9+

## 📈 性能监控

### 关键指标
- **应用启动时间**: < 2 秒
- **页面加载时间**: < 1 秒
- **搜索响应时间**: < 500ms
- **内存使用**: < 100MB

### 监控方法
- 使用 Instruments 进行性能分析
- 定期检查内存泄漏
- 监控异步操作的执行时间

## 🔍 问题解决方法论

- 全面阅读相关代码，理解 **Crulish** 应用的工作原理，特别是数据流和视图生命周期。
- 根据用户的反馈分析问题的原因，提出解决问题的思路。
- 确保每次代码变更不会破坏现有功能，且尽可能保持最小的改动。

## 🔄 迭代优化原则

- 与用户保持密切沟通，根据反馈调整功能和设计，确保应用符合用户需求。
- 在不确定需求时，主动询问用户以澄清需求或技术细节。
- 每次迭代都需要更新 `README.md` 文件，包括功能说明和优化建议。

## 🧠 开发方法论

- **系统2思维**：以分析严谨的方式解决问题。将需求分解为更小、可管理的部分，并在实施前仔细考虑每一步。
- **思维树**：评估多种可能的解决方案及其后果。使用结构化的方法探索不同的路径，并选择最优的解决方案。
- **迭代改进**：在最终确定代码之前，考虑改进、边缘情况和优化。通过潜在增强的迭代，确保最终解决方案是健壮的。
- **手动编译与运行**：在开发过程中，除了github mcp和本地文件系统涉及的git命令相关操作和内容外，其余内容的代码修改后，需要简略报告修改的内容，然后等待用户编译信息的反馈。将由用户手动进行编译和运行，并向你反馈运行结果和信息，你将根据反馈进行后续操作。手动反馈的编译用户正常运行后，才会认为修改有效。
**手动编译与运行**：
1. 代码修改后，ai助理需简要报告修改内容
2. 等待用户手动编译运行并反馈结果
3. GitHub MCP和本地Git操作除外
4. 内容修改需经用户确认运行正常后生效

## 🚀 部署规范

### 版本管理
- 使用语义化版本号 (Semantic Versioning)
- 每个版本都要有详细的更新日志

### 发布检查清单
- [ ] 所有测试通过
- [ ] 性能指标达标
- [ ] 错误处理完善
- [ ] 用户界面响应流畅
- [ ] 数据迁移测试完成
- [ ] SwiftData 模型兼容性验证
- [ ] 异步操作性能测试

---

**最后更新**: 2024年12月
**版本**: 2.0
**维护者**: 开发团队